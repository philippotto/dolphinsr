{"version":3,"file":"bundle.js","sources":["../lib/types.js","../lib/addReview.js","../lib/dateDiffInDays.js","../lib/computeCardsSchedule.js","../lib/applyReview.js","../lib/index.js"],"sourcesContent":["// @flow\n\nimport uuid from 'uuid-browser';\n\n// Generally all types should be considered opaque in application code.\n\n// -- Data types\n\nexport type Id = string;\nexport function generateId(): Id {\n  return uuid.v4();\n}\n\nexport type Field = string;\n\n// numbers are indexes on master.fields\nexport type Combination = {front: number[], back: number[], };\n\nexport type CardId = string;\nexport function getCardId(o: {master: Id, combination: Combination}): CardId {\n  return `${o.master}#${o.combination.front.join(',')}@${o.combination.back.join(',')}`;\n}\n\n\nexport type Master = {\n  id: Id,\n  fields: Array<Field>,\n  combinations: Array<Combination>,\n}\n\nexport type Rating = 'easy' | 'good' | 'hard' | 'again';\n\nexport type Review = {\n  master: Id,\n  combination: Combination,\n  ts: Date,\n  rating: Rating,\n}\n\n// -- Computed data types\n\nexport type Card = {\n  master: Id,\n  combination: Combination,\n  front: Field[],\n  back: Field[]\n};\n\nexport type LearningCardState = {\n  master: Id,\n  combination: Combination,\n\n  mode: 'learning',\n  consecutiveCorrect: number, // 0 <= consecutiveCorrect < 2, int\n  lastReviewed: ?Date\n};\nexport type ReviewingCardState = {\n  master: Id,\n  combination: Combination,\n\n  mode: 'reviewing',\n  factor: number, // float\n  lapses: number, // int\n  interval: number, // days since lastReviewed\n  lastReviewed: Date\n};\nexport type LapsedCardState = {\n  master: Id,\n  combination: Combination,\n\n  mode: 'lapsed',\n  consecutiveCorrect: number,\n  factor: number,\n  lapses: number,\n  interval: number,\n  lastReviewed: Date,\n};\nexport type CardState = LearningCardState | ReviewingCardState | LapsedCardState;\nexport function makeInitialCardState(master: Id, combination: Combination): LearningCardState {\n  return {\n    master,\n    combination,\n\n    mode: 'learning',\n    consecutiveCorrect: 0,\n    lastReviewed: null,\n  };\n}\n\nexport type State = {\n  cardStates: {[CardId]: CardState},\n};\nexport function makeEmptyState(): State {\n  return {\n    cardStates: {},\n  };\n}\n\nexport type Schedule = 'later' | 'due' | 'overdue' | 'learning';\nexport function cmpSchedule(a: Schedule, b: Schedule) {\n  const scheduleVals = {\n    later: 0,\n    due: 1,\n    overdue: 2,\n    learning: 3,\n  };\n  const diff = scheduleVals[b] - scheduleVals[a];\n  if (diff < 0) {\n    return -1;\n  } else if (diff > 0) {\n    return 1;\n  }\n  return 0;\n}\n\nexport type CardsSchedule = {\n  'later': Array<CardId>,\n  'due': Array<CardId>,\n  'overdue': Array<CardId>,\n  'learning': Array<CardId>\n};\n\nexport type SummaryStatistics = {\n  'later': number,\n  'due': number,\n  'overdue': number,\n  'learning': number\n};\n","// @flow\nimport type { Review } from './types';\n\n// This function only works if reviews is always sorted by timestamp\nexport default function addReview(reviews: Review[], review: Review): Review[] {\n  if (!reviews.length) {\n    return [review];\n  }\n\n  let i = reviews.length - 1;\n  for (; i >= 0; i -= 1) {\n    if (reviews[i].ts <= review.ts) {\n      break;\n    }\n  }\n\n  const newReviews = reviews.slice(0);\n  newReviews.splice(i + 1, 0, review);\n\n  return newReviews;\n}\n","// @flow\n\nexport default function dateDiffInDays(a: Date, b: Date): number {\n  // adapted from http://stackoverflow.com/a/15289883/251162\n  const MS_PER_DAY = 1000 * 60 * 60 * 24;\n\n  // Disstate the time and time-zone information.\n  const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());\n  const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());\n\n  return (utc2 - utc1) / MS_PER_DAY;\n}\n","// @flow\n\nimport type { CardState, ReviewingCardState, Schedule, CardsSchedule, State, CardId } from './types';\nimport { getCardId } from './types';\nimport dateDiffInDays from './dateDiffInDays';\n\n// assumes that the day starts at 3:00am in the local timezone\nexport function calculateDueDate(state: ReviewingCardState): Date {\n  const result = new Date(state.lastReviewed);\n  result.setHours(3, 0, 0);\n  result.setDate(result.getDate() + Math.ceil(state.interval));\n  return result;\n}\n\nexport function computeScheduleFromCardState(state: CardState, now: Date): Schedule {\n  if (state.mode === 'lapsed' || state.mode === 'learning') {\n    return 'learning';\n  } else if (state.mode === 'reviewing') {\n    const diff = dateDiffInDays(calculateDueDate(state), now);\n    if (diff < 0) {\n      return 'later';\n    } else if (diff >= 0 && diff < 1) {\n      return 'due';\n    } else if (diff >= 1) {\n      return 'overdue';\n    }\n  }\n  throw new Error('unreachable');\n}\n\n// Breaks ties first by last review (earlier beats later),\n// then by an alphabetical comparison of the cardId (just so it stays 100% deterministic)\n//\n// Returns null if no cards are due.\nexport function pickMostDue(s: CardsSchedule, state: State, forceNext: boolean = false): ?CardId {\n  const prec: Schedule[] = ['learning', 'overdue', 'due'].concat(forceNext ? ['later'] : []);\n  for (let i = 0; i < prec.length; i += 1) {\n    const sched = prec[i];\n    if (s[sched].length) {\n      return s[sched].slice(0).sort((a, b) => {\n        const cardA = state.cardStates[a];\n        const cardB = state.cardStates[b];\n        if (cardA == null) {\n          throw new Error(`id not found in state: ${a}`);\n        }\n        if (cardB == null) {\n          throw new Error(`id not found in state: ${b}`);\n        }\n\n        const reviewDiff = (\n          (cardA.lastReviewed == null && cardB.lastReviewed != null) ? 1 :\n          (cardB.lastReviewed == null && cardA.lastReviewed != null) ? -1 :\n          (cardA.lastReviewed == null && cardB.lastReviewed == null) ? 0 :\n          (cardB.lastReviewed: any) - (cardA.lastReviewed: any)\n        );\n        if (reviewDiff !== 0) {\n          return -reviewDiff;\n        }\n\n        if (a === b) {\n          throw new Error(`comparing duplicate id: ${a}`);\n        }\n        return b > a ? 1 : -1;\n      })[0];\n    }\n  }\n  return null;\n}\n\nexport default function computeCardsSchedule(state: State, now: Date): CardsSchedule {\n  const s: CardsSchedule = {\n    learning: [],\n    later: [],\n    due: [],\n    overdue: [],\n  };\n  Object.keys(state.cardStates).forEach((cardId) => {\n    const cardState = state.cardStates[cardId];\n    s[computeScheduleFromCardState(cardState, now)].push(getCardId(cardState));\n  });\n  return s;\n}\n","// @flow\n\nimport type { State, CardState, LearningCardState, ReviewingCardState, LapsedCardState, Review, Rating } from './types';\nimport { getCardId } from './types';\nimport dateDiffInDays from './dateDiffInDays';\nimport { calculateDueDate } from './computeCardsSchedule';\n\nconst debug = require('debug')('dolphin');\n\n// -- applyToLearningCardState(...)\n\n// constants from Anki defaults\n// TODO(April 1, 2017) investigate rationales, consider changing them\nconst INITIAL_FACTOR = 2500;\nconst INITIAL_DAYS_WITHOUT_JUMP = 4;\nconst INITIAL_DAYS_WITH_JUMP = 1;\nfunction applyToLearningCardState(prev: LearningCardState, ts: Date, rating: Rating): CardState {\n  if (rating === 'easy' || (rating.match(/^easy|good$/) && prev.consecutiveCorrect > 0)) {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'reviewing',\n      factor: INITIAL_FACTOR,\n      lapses: 0,\n      interval: prev.consecutiveCorrect > 0 ? INITIAL_DAYS_WITHOUT_JUMP : INITIAL_DAYS_WITH_JUMP,\n      lastReviewed: ts,\n    };\n  } else if (rating === 'again') {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'learning',\n      consecutiveCorrect: 0,\n      lastReviewed: ts,\n    };\n  } else if (rating.match(/^good|hard$/)) {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'learning',\n      consecutiveCorrect: prev.consecutiveCorrect + 1,\n      lastReviewed: ts,\n    };\n  }\n  throw new Error('logic error');\n}\n\n// -- applyToReviewingCardState(...)\n\nconst EASY_BONUS = 2;\nconst MAX_INTERVAL = 365;\nconst MIN_FACTOR = 0; // TODO\nconst MAX_FACTOR = Number.MAX_VALUE;\nfunction constrainWithin(min, max, n) {\n  // if (min > max) {\n  //   throw new Error(`min > max: ${min}=min, ${max}=max`);\n  // }\n  return Math.max(Math.min(n, max), min);\n}\n\nfunction calculateDaysLate(state: ReviewingCardState, actual: Date): number {\n  const expected = calculateDueDate(state);\n\n  const daysLate = dateDiffInDays(actual, expected);\n\n  if (daysLate < 0) {\n    debug('last review occured earlier than expected', {\n      daysLate,\n      actual,\n      expected,\n    });\n    return 0;\n  }\n\n  return daysLate;\n}\nfunction applyToReviewingCardState(prev: ReviewingCardState, ts: Date, rating: Rating): CardState {\n  if (rating === 'again') {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'lapsed',\n      consecutiveCorrect: 0,\n      factor: constrainWithin(MIN_FACTOR, MAX_FACTOR, prev.factor - 200),\n      lapses: prev.lapses + 1,\n      interval: prev.interval,\n      lastReviewed: ts,\n    };\n  }\n  const factorAdj = (\n    rating === 'hard' ? -150 :\n    rating === 'good' ? 0 :\n    rating === 'easy' ? 150 :\n    NaN\n  );\n  const daysLate = calculateDaysLate(prev, ts);\n\n  const ival = constrainWithin(prev.interval + 1, MAX_INTERVAL,\n    rating === 'hard' ? (prev.interval + (daysLate / 4)) * 1.2 :\n    rating === 'good' ? ((prev.interval + (daysLate / 2)) * prev.factor) / 1000 :\n    rating === 'easy' ? (((prev.interval + daysLate) * prev.factor) / 1000) * EASY_BONUS :\n    NaN,\n  );\n\n  if (isNaN(factorAdj) || isNaN(ival)) {\n    throw new Error(`invalid rating: ${rating}`);\n  }\n\n  return {\n    master: prev.master,\n    combination: prev.combination,\n\n    mode: 'reviewing',\n    factor: constrainWithin(MIN_FACTOR, MAX_FACTOR, prev.factor + factorAdj),\n    lapses: prev.lapses,\n    interval: ival,\n    lastReviewed: ts,\n  };\n}\n\n// -- applyToLapsedCardState(...)\n\nfunction applyToLapsedCardState(prev: LapsedCardState, ts: Date, rating: Rating): CardState {\n  if (rating === 'easy' || (rating.match(/^easy|good$/) && prev.consecutiveCorrect > 0)) {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'reviewing',\n      factor: prev.factor,\n      lapses: prev.lapses,\n      interval: prev.consecutiveCorrect > 0 ? INITIAL_DAYS_WITHOUT_JUMP : INITIAL_DAYS_WITH_JUMP,\n      lastReviewed: ts,\n    };\n  }\n  return {\n    master: prev.master,\n    combination: prev.combination,\n\n    mode: 'lapsed',\n    factor: prev.factor,\n    lapses: prev.lapses,\n    interval: prev.interval,\n    lastReviewed: ts,\n    consecutiveCorrect: rating === 'again' ? 0 : prev.consecutiveCorrect + 1,\n  };\n}\n\n// -- applyReview(...)\n\n\nexport function applyToCardState(prev: CardState, ts: Date, rating: Rating): CardState {\n  if (prev.lastReviewed != null && prev.lastReviewed > ts) {\n    const p = prev.lastReviewed.toISOString();\n    const t = ts.toISOString();\n    throw new Error(`cannot apply review before current lastReviewed: ${p} > ${t}`);\n  }\n\n  if (prev.mode === 'learning') {\n    return applyToLearningCardState((prev: any), ts, rating);\n  } else if (prev.mode === 'reviewing') {\n    return applyToReviewingCardState((prev: any), ts, rating);\n  } else if (prev.mode === 'lapsed') {\n    return applyToLapsedCardState((prev: any), ts, rating);\n  }\n  throw new Error(`invalid mode: ${prev.mode}`);\n}\n\nexport default function applyReview(prev: State, review: Review): State {\n  const cardId = getCardId(review);\n\n  const cardState = prev.cardStates[cardId];\n  if (cardState == null) {\n    throw new Error(`applying review to missing card: ${JSON.stringify(review)}`);\n  }\n\n  const state = {\n    cardStates: { ...prev.cardStates },\n  };\n  state.cardStates[cardId] = applyToCardState(cardState, review.ts, review.rating);\n\n  return state;\n}\n","// @flow\n\nimport type {\n  State, Master, Review, Id, CardId, CardsSchedule, Card, SummaryStatistics,\n} from './types';\nimport { makeEmptyState, getCardId, makeInitialCardState, generateId } from './types';\nimport addReview from './addReview';\nimport applyReview from './applyReview';\nimport computeCardsSchedule, { pickMostDue } from './computeCardsSchedule';\n\nexport type { Master, Review, Id, Card, SummaryStatistics };\nexport { generateId };\n\nconst debug = require('debug')('dolphin');\n\nexport class DolphinSR {\n\n  _state: State;\n  _masters: {[Id]: Master};\n  _reviews: Array<Review>;\n\n  // TODO(April 3, 2017)\n  // Currently the cachedCardsSchedule is not invalidated when the time changes (only when a review\n  // or master is added), so there is a possibility for cards not switching from due to overdue\n  // properly. In practice, this has not been a significant issue -- easy fix for later.\n  _cachedCardsSchedule: ?CardsSchedule;\n\n  // For testing, you can swap this out with a different function to change when 'now' is.\n  _currentDateGetter: () => Date;\n\n\n  constructor(currentDateGetter: () => Date = () => new Date()) {\n    this._state = makeEmptyState();\n    this._masters = {};\n    this._reviews = [];\n    this._currentDateGetter = currentDateGetter;\n  }\n\n  // gotcha: does not invalidate cache, that happens in addMasters()\n  _addMaster(master: Master) {\n    if (this._masters[master.id]) {\n      throw new Error(`master already added: ${master.id}`);\n    }\n    master.combinations.forEach((combination) => {\n      const id = getCardId({ master: master.id, combination });\n      this._state.cardStates[id] = makeInitialCardState(master.id, combination);\n    });\n    this._masters[master.id] = master;\n  }\n\n  addMasters(...masters: Array<Master>) {\n    masters.forEach(master => this._addMaster(master));\n    this._cachedCardsSchedule = null;\n  }\n\n  // gotcha: does not apply the reviews to state or invalidate cache, that happens in addReviews()\n  _addReviewToReviews(review: Review): boolean {\n    this._reviews = addReview(this._reviews, review);\n    const lastReview = this._reviews[this._reviews.length - 1];\n\n    return (\n      `${getCardId(lastReview)}#${lastReview.ts.toISOString()}` !==\n      `${getCardId(review)}#${review.ts.toISOString()}`\n    );\n  }\n\n  // Returns true if the entire state was rebuilt (inefficient, minimize)\n  addReviews(...reviews: Array<Review>): boolean {\n    const needsRebuild = reviews.reduce((v, review) => {\n      if (this._addReviewToReviews(review)) {\n        return true;\n      }\n      return v;\n    }, false);\n\n    if (needsRebuild) {\n      this._rebuild();\n    } else {\n      reviews.forEach((review) => {\n        this._state = applyReview(this._state, review);\n      });\n    }\n\n    this._cachedCardsSchedule = null;\n\n    return needsRebuild;\n  }\n\n  _rebuild() {\n    debug('rebuilding state');\n    const masters = this._masters;\n    const reviews = this._reviews;\n    this._masters = {};\n    this._reviews = [];\n\n    this.addMasters(...Object.keys(masters).map(k => masters[k]));\n    this.addReviews(...reviews);\n  }\n\n  _getCardsSchedule(): CardsSchedule {\n    if (this._cachedCardsSchedule != null) {\n      return this._cachedCardsSchedule;\n    }\n    this._cachedCardsSchedule = computeCardsSchedule(this._state, this._currentDateGetter());\n    return this._cachedCardsSchedule;\n  }\n\n  _nextCardId(forceNext: boolean = false): ?CardId {\n    const s = this._getCardsSchedule();\n    return pickMostDue(s, this._state, forceNext);\n  }\n\n  _getCard(id: CardId): Card {\n    const [masterId, combo] = id.split('#');\n    const [front, back] = combo.split('@').map(part => part.split(',').map(x => parseInt(x, 10)));\n    const master = this._masters[masterId];\n    if (master == null) {\n      throw new Error(`cannot getCard: no such master: ${masterId}`);\n    }\n    const combination = { front, back };\n\n    const frontFields = front.map(i => master.fields[i]);\n    const backFields = back.map(i => master.fields[i]);\n\n    return {\n      master: masterId,\n      combination,\n\n      front: frontFields,\n      back: backFields,\n    };\n  }\n\n  nextCard(forceNext: boolean = false): ?Card {\n    const cardId = this._nextCardId(forceNext);\n    if (cardId == null) {\n      return null;\n    }\n    return this._getCard(cardId);\n  }\n\n  summary(): SummaryStatistics {\n    const s = this._getCardsSchedule();\n    return {\n      due: s.due.length,\n      later: s.later.length,\n      learning: s.learning.length,\n      overdue: s.overdue.length,\n    };\n  }\n}\n"],"names":["generateId","uuid","v4","getCardId","o","master","combination","front","join","back","makeInitialCardState","makeEmptyState","addReview","reviews","review","length","i","ts","newReviews","slice","splice","dateDiffInDays","a","b","MS_PER_DAY","utc1","Date","UTC","getFullYear","getMonth","getDate","utc2","calculateDueDate","state","result","lastReviewed","setHours","setDate","Math","ceil","interval","computeScheduleFromCardState","now","mode","diff","Error","pickMostDue","s","forceNext","prec","concat","sched","sort","cardA","cardStates","cardB","reviewDiff","computeCardsSchedule","keys","forEach","cardId","cardState","push","debug","require","INITIAL_FACTOR","INITIAL_DAYS_WITHOUT_JUMP","INITIAL_DAYS_WITH_JUMP","applyToLearningCardState","prev","rating","match","consecutiveCorrect","EASY_BONUS","MAX_INTERVAL","MIN_FACTOR","MAX_FACTOR","Number","MAX_VALUE","constrainWithin","min","max","n","calculateDaysLate","actual","expected","daysLate","applyToReviewingCardState","factor","lapses","factorAdj","NaN","ival","isNaN","applyToLapsedCardState","applyToCardState","p","toISOString","t","applyReview","JSON","stringify","DolphinSR","currentDateGetter","_state","_masters","_reviews","_currentDateGetter","id","combinations","masters","_addMaster","_cachedCardsSchedule","lastReview","needsRebuild","reduce","v","_addReviewToReviews","_rebuild","addMasters","Object","map","k","addReviews","_getCardsSchedule","split","masterId","combo","part","parseInt","x","frontFields","fields","backFields","_nextCardId","_getCard","due","later","learning","overdue"],"mappings":"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"}